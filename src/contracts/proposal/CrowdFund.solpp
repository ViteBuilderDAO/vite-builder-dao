pragma soliditypp ^0.4.3;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath
{

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c)
  {
    if (a == 0)
    {
      return 0;
    }
    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256)
  {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256)
  {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c)
  {
    c = a + b;
    assert(c >= a);
    return c;
  }
}

contract Project
{
    using SafeMath for uint256;

    // Data structures
    enum State
    {
        Fundraising,
        Complete
    }

    // Project Type Obj and it's map container
    // mapping from numberofProposals to ProjectObj
    mapping(uint256 => ProjectObj) projectsMap;
    struct ProjectObj
    {
      address _creator;
      string _title;
      string _description;
      uint _raiseUntil;
      uint256 _balance;
      State _state;
      bytes32 payoutHash;
      mapping (address => uint) _contributions;
    }

    //
    uint256 public currNumberOfProposals = 0;
    address contractStarter;

    // Event that will be emitted whenever a new project is started
    event ProjectStarted(
        address _projectStarter,
        string _projectTitle,
        string _projectDesc,
        uint256 _deadline,
        uint256 _projectId
    );

    // Event that will be emitted whenever a project ends
    event ProjectEnded(
        uint256 _projectId,
        uint _proposalEndTime
    );

    event FundingReceived(uint256 projectId, address contributor, uint amount, uint currentTotal);
    event ProposalPaid(uint256 projectId, address _recipient);

    constructor() public payable
    {
      contractStarter = msg.sender;
    }

    /** @dev Function to get all projects' contract addresses.
      * @return A list of all projects' contract addreses
      */
    //getter returnAllProjects() returns(ProjectObj memory)
    //{
    //    return projectsMap;
    //}

    /** @dev Function to start a new project.
      * @param _title Title of the project to be created
      * @param _description Brief description about the project
      * @param _durationInDays Project deadline in days
      */
    onMessage startProject(
        string calldata _title,
        string calldata _description,
        uint _durationInDays)
    {
        uint raiseUntil = now.add(_durationInDays.mul(1 days));
        projectsMap[++currNumberOfProposals] = ProjectObj(msg.sender, _title, _description, raiseUntil, 0, State.Fundraising, 0);
        emit ProjectStarted(
            msg.sender,
            _title,
            _description,
            raiseUntil,
            currNumberOfProposals
        );
    }                                                                                                                              

    /** @dev Function to fund a certain project.
      */
    function contribute(uint256 projectID, uint256 amountValue) public
    {
        uint256 index = projectID - 1;
        require(msg.sender != projectsMap[index]._creator);
        uint256 prevContributions = projectsMap[index]._contributions[msg.sender];
        projectsMap[index]._contributions[msg.sender] = prevContributions.add(amountValue);
        projectsMap[index]._balance = projectsMap[index]._balance.add(amountValue);
        emit FundingReceived(projectID, msg.sender, amountValue, projectsMap[index]._balance);
        requestPayOutOnComplete(projectID);
    }

    /** @dev Function to change the project state depending on conditions.
      */
    function requestPayOutOnComplete(uint256 projectID) public
    {
        // FIX ME - HARDCODED - ZD
        uint256 index = projectID - 1;
        require(projectsMap[index]._creator == msg.sender);
        if (now > projectsMap[index]._raiseUntil)
        {
            projectsMap[index]._state = State.Complete;
            payOut(index, "tti_5649544520544f4b454e6e40");
        }
        emit ProjectEnded(projectID, now);
    }

    /** @dev Function to give the received funds to project starter.
      */
    function payOut(uint256 _projectID, tokenId _tokenId) internal
    {
        uint256 index = _projectID - 1;
        require(projectsMap[index]._state == State.Complete);
        address proposalCreator = projectsMap[index]._creator;
        require(proposalCreator != address(0), 'transfer to zero address');
        uint256 totalRaised = projectsMap[index]._balance;
        projectsMap[index]._state = State.Complete;
        projectsMap[index]._balance = 0;
        proposalCreator.transfer(_tokenId, totalRaised);
        emit ProposalPaid(_projectID, proposalCreator);
    }

    /** @dev Function to get specific information about the project.
      * @return Returns all the project's details
      */
    function getDetails(uint256 projectID) public view returns(
        address _creator,
        string memory _projectTitle,
        string memory _projectDesc,
        uint256 _deadline,
        State _currentState,
        uint256 _currentAmount)
    {
        uint256 index = projectID - 1;
        _creator = projectsMap[index]._creator;
        _projectTitle = projectsMap[index]._title;
        _projectDesc = projectsMap[index]._description;
        _deadline = projectsMap[index]._raiseUntil;
        _currentState = projectsMap[index]._state;
        _currentAmount = projectsMap[index]._balance;
    }
}