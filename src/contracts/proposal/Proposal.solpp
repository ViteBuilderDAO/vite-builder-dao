pragma soliditypp ^0.4.3;

import "./proposal-libs/SafeMath.solpp";

contract DefaultProposal
{
  using SafeMath for uint256;

  // Various states that a proposal can be in
  enum State
  {
    Active,   // Blue (Vite blue)
    Approved, // Green
    Rejected, // Red
    Cancelled // Gray
  }

  struct ProposalVote
  {
    uint256 m_voteToken;
    uint256 m_votePower;
  }

  struct ProposalOption
  {
    uint256 m_optionID;
    uint256 m_optionTitle;
    uint256 m_optionsVotePower;
    uint256 m_optionsTotalVotes;
    ProposalVote[] m_votingInfoArr;
    mapping(uint256 => ProposalVote) m_voteMap;
  }

  // Proposal Type Obj and it's map container
  struct ProposalObj
  {
    uint256 m_id;
    address m_creator;
    string m_title;
    string m_urlLink;
    string m_keywords;
    string m_description;
    uint m_numOptions;
    ProposalOption[] m_optionsArr;
    string m_coverImage;
    uint256[] m_attachedFiles;
    string m_votingType;
    string m_publishDate;
    uint m_deadline;
    uint256[] m_votingTokens;
    uint256 m_totalVotingPower;
    uint256 m_totalVotes;
    State m_state;
  }

  ProposalObj[] g_proposalsArr;

  // Number of proposals currently active
  uint256 g_totalNumProposals = 0;
  // Address of the contract creator
  address g_contractOwner;

  // Event that will be emitted whenever a new proposal is created
  event ProposalStartedEvent(
    uint256 indexed proposalID,
    address indexed proposalStarter,
    string proposalTitle,
    string proposalURL,
    string proposalKeywords,
    string proposalDesc,
    uint numOptions,
    uint256[] optionsArr,
    string coverImage,
    uint256[] attachedFiles,
    string votingType,
    string publishDate,
    uint256 proposalDeadline,
    uint256[] votingTokens
  );

  // Event that will be emitted whenever a proposal ends
  event ProposalEndedEvent(
    uint256 indexed proposalID,
    uint256 proposalEndTime
  );

  // Event emitted whenever a proposal receives a vote
  event ProposalVotedOnEvent(
    uint256 indexed proposalID,
    address indexed proposalVoter,
    uint256 votingToken,
    uint256 votingPower,
    uint256 proposalTotalVotingPower,
    uint256 proposalTotalVotes
  );

  // Event emitted when a proposal has ended and results are calculated
  event ProposalResultsCalculated(
    uint256 indexed proposalID,
    address indexed proposalCreator,
    uint256 winningOptionVotes,
    uint256 totalVotes,
    uint256 totalVotingPower
  );

  /** @dev Contract Constructor
    */
  constructor() public
  {
    g_contractOwner = msg.sender;
  }

  /** @dev Function to start a new proposal.
    *
    */
  onMessage startProposal(
    address creator,
    string calldata title,
    string calldata urlLink,
    string calldata keywords,
    string calldata description,
    uint numOptions,
    uint256[] calldata optionsArr,
    string calldata coverImage,
    uint256[] calldata attachedFiles,
    string calldata votingType,
    string calldata publishDate,
    uint durationInDays,
    uint256[] calldata votingTokens)
  {
    uint proposalDeadline = now.add(durationInDays.mul(1 days));
    uint256 proposalID = ++g_totalNumProposals;
    ProposalVote[] memory votesArr;
    ProposalOption[] memory optsArr;
    for (uint i = 0; i < numOptions; ++i)
    {
      optsArr[i] = ProposalOption(i, optionsArr[i], 0, 0, votesArr);
    }

    g_proposalsArr.push(
      ProposalObj(
        proposalID,
        creator,
        title,
        urlLink,
        keywords,
        description,
        numOptions,
        optsArr,
        coverImage,
        attachedFiles,
        votingType,
        publishDate,
        proposalDeadline,
        votingTokens,
        0, 0,
        State.Active
      ));

    emit ProposalStartedEvent(
      proposalID,
      creator,
      title,
      urlLink,
      keywords,
      description,
      numOptions,
      optionsArr,
      coverImage,
      attachedFiles,
      votingType,
      publishDate,
      proposalDeadline,
      votingTokens
    );
  }                                                                                                                              

  /** @dev Function to vote on a given proposal.
    *
    */
  onMessage voteOnProposal(address voter, uint256 proposalID, uint256 voteToken, uint256 voterPower, uint optionNumber)
  {
    //require(g_proposalsArr[proposalID].m_creator != voter);

    ++g_proposalsArr[proposalID].m_optionsArr[optionNumber].m_optionsTotalVotes;
    g_proposalsArr[proposalID].m_optionsArr[optionNumber].m_votingInfoArr.push(ProposalVote(voteToken, voterPower));
    g_proposalsArr[proposalID].m_optionsArr[optionNumber].m_optionsVotePower = g_proposalsArr[proposalID].m_optionsArr[optionNumber].m_optionsVotePower.add(voterPower);
    g_proposalsArr[proposalID].m_totalVotingPower = g_proposalsArr[proposalID].m_totalVotingPower.add(voterPower);
    g_proposalsArr[proposalID].m_optionsArr[optionNumber].m_voteMap[voteToken].m_votePower = g_proposalsArr[proposalID].m_optionsArr[optionNumber].m_voteMap[voteToken].m_votePower.add(voterPower);

    emit ProposalVotedOnEvent(proposalID, voter, voteToken, voterPower, g_proposalsArr[proposalID].m_totalVotingPower, ++g_proposalsArr[proposalID].m_totalVotes);

    _checkIsComplete(proposalID);
  }

  /** @dev Stop the proposal (only if it is complete)
    * Should be used in pair with getIsProposalComplete()
    */
  onMessage stopProposal(uint256 proposalID)
  {
    _checkIsComplete(proposalID);
  }

  /** @dev Stop the proposal early if desired (mostly for testing purposes)
    *
    */
  onMessage stopProposalEarly(uint256 proposalID)
  {
    require(g_proposalsArr[proposalID].m_creator == msg.sender);

    g_proposalsArr[proposalID].m_state = State.Cancelled;
    _calculateResults(proposalID);

    emit ProposalEndedEvent(proposalID, now);
  }

  /** @dev
    */
  getter getNumProposals() returns(uint256 numProposals)
  {
    return g_totalNumProposals;
  }

  /** @dev
    */
  getter getProposalByID(uint256 proposalID) returns (
    address creator,
    string memory title,
    string memory urlLink,
    string memory keywords,
    string memory description,
    uint numOptions,
    uint256[] memory optionsArr,
    uint256[] memory optionsVotePowers,
    uint256[] memory optionsTotalVotes,
    string memory coverImage,
    uint256[] memory attachedFiles,
    string memory votingType,
    string memory publishDate,
    uint deadline,
    uint256[] memory votingTokens,
    uint256 totalVotingPower,
    uint256 totalVotes,
    string memory state)
  {
    state = "";
    if (_checkIsComplete(proposalID))
    {
      state = "Complete";
    }
    else
    {
      state = "Active";
    }

    creator = g_proposalsArr[proposalID].m_creator;
    title = g_proposalsArr[proposalID].m_title;
    urlLink = g_proposalsArr[proposalID].m_urlLink;
    keywords = g_proposalsArr[proposalID].m_keywords;
    description = g_proposalsArr[proposalID].m_description;
    numOptions = g_proposalsArr[proposalID].m_numOptions;

    optionsArr = new uint256[](numOptions);
    optionsVotePowers = new uint256[](numOptions);
    optionsTotalVotes = new uint256[](numOptions);
    for (uint i = 0; i < numOptions; ++i)
    {
      optionsArr[i] = g_proposalsArr[proposalID].m_optionsArr[i].m_optionTitle;
      optionsVotePowers[i] = g_proposalsArr[proposalID].m_optionsArr[i].m_optionsVotePower;
      optionsTotalVotes[i] = g_proposalsArr[proposalID].m_optionsArr[i].m_optionsTotalVotes;
    }

    coverImage = g_proposalsArr[proposalID].m_coverImage;
    attachedFiles = g_proposalsArr[proposalID].m_attachedFiles;
    votingType = g_proposalsArr[proposalID].m_votingType;
    publishDate = g_proposalsArr[proposalID].m_publishDate;
    deadline = g_proposalsArr[proposalID].m_deadline;
    votingTokens =  g_proposalsArr[proposalID].m_votingTokens;
    totalVotingPower = g_proposalsArr[proposalID].m_totalVotingPower;
    totalVotes = g_proposalsArr[proposalID].m_totalVotes;
  }

  /** @dev
    */
  getter getIsProposalComplete(uint256 proposalID) returns(bool isComplete)
  {
    if (now > g_proposalsArr[proposalID].m_deadline)
    {
      return true;
    }

    return false;
  }

  /** @dev Convert a string to uint256
    *
    */
  function _stringToUint(string memory _str) internal pure returns(uint256 res)
  {
    for (uint256 i = 0; i < bytes(_str).length; ++i)
    {
      if ((uint8(bytes(_str)[i]) - 48) < 0 || (uint8(bytes(_str)[i]) - 48) > 9)
      {
        return 0;
      }
      res += (uint8(bytes(_str)[i]) - 48) * 10**(bytes(_str).length - i - 1);
    }

    return res;
  }

  /** @dev Function to change the proposal state depending on conditions.
    *
    */
  function _checkIsComplete(uint256 proposalID) internal returns(bool)
  {
    // require(g_proposalsArr[proposalID].m_creator == msg.sender);

    if (now > g_proposalsArr[proposalID].m_deadline)
    {
        _calculateResults(proposalID);
        emit ProposalEndedEvent(proposalID, now);
        return true;
    }

    return false;
  }

  /** @dev Function to calculate results of proposal when complete
    *
    */
  function _calculateResults(uint256 proposalID) internal
  {
    // require(g_proposalsArr[proposalID].m_state == State.Complete);

    // Proposal creator
    address proposalCreator = g_proposalsArr[proposalID].m_creator;

    // Winning option and num votes
    uint index = 0;
    ProposalOption memory winningOption = g_proposalsArr[proposalID].m_optionsArr[index];
    for (index = 1; index < g_proposalsArr[proposalID].m_numOptions; ++index)
    {
      if (winningOption.m_optionsVotePower < g_proposalsArr[proposalID].m_optionsArr[index].m_optionsVotePower)
        winningOption = g_proposalsArr[proposalID].m_optionsArr[index];
    }
    uint256 winningOptionVotes = winningOption.m_optionsTotalVotes;

    // Total votes
    uint256 totalVotes = g_proposalsArr[proposalID].m_totalVotes;

    // Total voting power
    uint256 totalVotingPower = g_proposalsArr[proposalID].m_totalVotingPower;

    // Set the proposal state to complete (may already be set, but just in case)
    // FIX ME
    // Active, Approved, Rejected, Cancelled;
    if (index == 0)
      g_proposalsArr[proposalID].m_state = State.Approved;
    else if (index == 1)
      g_proposalsArr[proposalID].m_state = State.Rejected;

    emit ProposalResultsCalculated(proposalID, proposalCreator, winningOptionVotes, totalVotes, totalVotingPower);
  }
}