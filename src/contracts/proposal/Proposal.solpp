pragma soliditypp ^0.4.3;

import "./proposal-libs/SafeMath.solpp";
import "./proposal-libs/ProposalTimer.solpp";

contract DefaultProposal
{
  using SafeMath for uint;

  message startTimer(string proposalID, uint deadline);

  // Various states that a proposal can be in
  enum State
  {
    Active,   // Blue (Vite blue)
    Approved, // Green
    Rejected, // Red
    Cancelled // Grey
  }

  // Used for tracking individual option voting stats
  // Stats are used at proposal completion to calculate results
  struct OptionsVotingStats
  {
    uint m_optionTotalVotes;
    uint m_optionVotingPower;
  }

  // Saves results of completed proposals
  struct ProposalResults
  {
    uint m_winningOptionIndex;
    uint m_winningOptionTotalVotes;
    uint m_winningOptionVotingPower;
    State m_finalState;
  }

  // Proposal Type Obj and it's map container
  struct ProposalObj
  {
    string m_id;
    address m_creator;
    string m_title;
    uint m_publishDate;
    uint m_deadline;
    uint m_numOptions;
    string[] m_castedVotes;
    mapping(uint => OptionsVotingStats) m_optVoteStatsMap;
    uint m_totalVotingPower;
    uint m_totalVotes;
    State m_state;
    mapping(address => bool) m_prevVotersMap;
  }

  // Global proposals container
  mapping(string => ProposalObj) g_ProposalsMap;
  // Global proposal results container for saving after completion
  mapping(string => ProposalResults) g_ProposalResultsMap;

  // Address of the contract creator
  address g_contractOwner;

  // Number of proposals total
  uint g_TotalNumProposals;
  // Number of proposals active
  uint g_TotalActiveProposals;
  // Number of proposals approved
  uint g_TotalApprovedProposals;
  // Number of proposals rejected
  uint g_TotalRejectedProposals;
  // Number of proposals cancelled
  uint g_TotalCancelledProposals;

  // Event that will be emitted whenever a new proposal is created
  event ProposalStartedEvent(string proposalID, address proposalCreator, string proposalTitle, uint proposalDeadline, uint totalNumProposals, uint totalActiveProposals);

  // Event that will be emitted whenever a proposal ends
  event ProposalEndedEvent(string proposalID, address proposalCreator, uint endDate, string proposalTitle, string proposalStatus);

  // Event emitted whenever a proposal receives a vote
  event ProposalVotedOnEvent(string proposalID, address proposalVoter, string dataHash, uint totalVotingPower, uint totalVotes);


  /** @dev Contract Constructor
    */
  constructor() public
  {
    g_contractOwner = msg.sender;
  }


  /** @dev Function to start a new proposal.
    *
    */
  onMessage startProposal(string calldata id, address creator, string calldata title, uint durationInHours, uint numOptions)
  {
    uint proposalDeadline = now.add(durationInHours.mul(1 hours));

    g_ProposalsMap[id] = (ProposalObj(id, creator, title, now, proposalDeadline, numOptions, new string[](0), 0, 0, State.Active));

    for (uint i = 0; i < numOptions; ++i)
    {
      g_ProposalsMap[id].m_optVoteStatsMap[i] = OptionsVotingStats(0, 0);
    }

    ++g_TotalNumProposals;
    ++g_TotalActiveProposals;

    send(creator, startTimer(id, proposalDeadline));

    emit ProposalStartedEvent(id, creator, title, proposalDeadline, g_TotalNumProposals, g_TotalActiveProposals);
  }


  /** @dev Function to vote on a given proposal.
    *
    */
  onMessage voteOnProposal(string calldata proposalID, address voter, uint voterPower, uint[] calldata optPowers, string calldata dataHash)
  {
    require(!g_ProposalsMap[proposalID].m_prevVotersMap[voter]);
    require(now < g_ProposalsMap[proposalID].m_deadline);

    uint proposalTotalPower = g_ProposalsMap[proposalID].m_totalVotingPower.add(voterPower);
    uint proposalTotalVotes = ++g_ProposalsMap[proposalID].m_totalVotes;
    g_ProposalsMap[proposalID].m_totalVotingPower = proposalTotalPower;
    g_ProposalsMap[proposalID].m_prevVotersMap[voter] = true;
    g_ProposalsMap[proposalID].m_castedVotes.push(dataHash);

    for (uint i = 0; i < optPowers.length; ++i)
    {
      ++g_ProposalsMap[proposalID].m_optVoteStatsMap[i].m_optionTotalVotes;
      g_ProposalsMap[proposalID].m_optVoteStatsMap[i].m_optionVotingPower = g_ProposalsMap[proposalID].m_optVoteStatsMap[i].m_optionVotingPower.add(optPowers[i]);
    }

    emit ProposalVotedOnEvent(proposalID, voter, dataHash, proposalTotalPower, proposalTotalVotes);
  }


  /** @dev Stop the proposal (only if it is complete)
    * Should be used in pair with getIsProposalComplete()
    */
  onMessage stopProposal(string calldata proposalID)
  {
    _checkIsComplete(proposalID);
  }


  /** @dev Stop the proposal early if desired (mostly for testing purposes)
    *
    */
  onMessage stopProposalEarly(string calldata proposalID)
  {
    require(g_ProposalsMap[proposalID].m_creator == msg.sender);

    g_ProposalsMap[proposalID].m_state = State.Cancelled;

    _calcResults(proposalID);

    emit ProposalEndedEvent(proposalID, g_ProposalsMap[proposalID].m_creator, now, g_ProposalsMap[proposalID].m_title, _stateToString(g_ProposalsMap[proposalID].m_state));
  }


  /**
    */
  getter getProposalStats() returns(uint total, uint active, uint approved, uint rejected, uint cancelled)
  {
    total = g_TotalNumProposals;
    active = g_TotalActiveProposals;
    approved = g_TotalApprovedProposals;
    rejected = g_TotalRejectedProposals;
    cancelled = g_TotalCancelledProposals;
  }


  /**
    */
  getter getProposalVotingStats(string calldata proposalID) returns(uint totalVotingPower, uint totalVotes)
  {
    totalVotingPower = g_ProposalsMap[proposalID].m_totalVotingPower;
    totalVotes = g_ProposalsMap[proposalID].m_totalVotes;
  }


  /**
    */
  getter getProposalByID(string calldata proposalID) returns (
    address creator,
    string memory title,
    uint publishDate,
    uint deadline,
    uint totalVotingPower,
    uint totalVotes,
    string memory state)
  {
    creator = g_ProposalsMap[proposalID].m_creator;
    title = g_ProposalsMap[proposalID].m_title;
    publishDate = g_ProposalsMap[proposalID].m_publishDate;
    deadline = g_ProposalsMap[proposalID].m_deadline;
    totalVotingPower = g_ProposalsMap[proposalID].m_totalVotingPower;
    totalVotes = g_ProposalsMap[proposalID].m_totalVotes;
    state = _stateToString(g_ProposalsMap[proposalID].m_state);
  }


  /**
    */
  getter checkIfVotedPreviously(address voter, string calldata proposalID) returns (bool hasVoted)
  {
    hasVoted = g_ProposalsMap[proposalID].m_prevVotersMap[voter];
  }


  /**
    */
  getter getIsProposalComplete(string calldata proposalID) returns(bool isComplete)
  {
    if (now > g_ProposalsMap[proposalID].m_deadline)
    {
      return true;
    }

    return false;
  }


  /** @dev Convert a string to uint
    *
    */
  function _stateToString(State _state) internal pure returns(string memory strRes)
  {
    if (_state == State.Active)
    {
      strRes = "Active";
    }
    else if (_state == State.Approved)
    {
      strRes = "Approved";
    }
    else if (_state == State.Rejected)
    {
      strRes = "Rejected";
    }
    else if (_state == State.Cancelled)
    {
      strRes = "Cancelled";
    }
    else
    {
      strRes = "Unknown";
    }
  }


  /** @dev Function to change the proposal state depending on conditions.
    *
    */
  function _checkIsComplete(string memory proposalID) internal returns(bool)
  {
    // require(g_ProposalsMap[proposalID].m_creator == msg.sender);

    if (now > g_ProposalsMap[proposalID].m_deadline)
    {
      _calcResults(proposalID);
      emit ProposalEndedEvent(proposalID, g_ProposalsMap[proposalID].m_creator, now, g_ProposalsMap[proposalID].m_title, _stateToString(g_ProposalsMap[proposalID].m_state));
      return true;
    }

    return false;
  }


  function _calcResults(string memory proposalID) internal
  {
    ProposalResults memory results = ProposalResults(0, 0, 0, State.Cancelled);
    if (g_ProposalsMap[proposalID].m_totalVotes > 0)
    {
      results.m_winningOptionTotalVotes = g_ProposalsMap[proposalID].m_optVoteStatsMap[0].m_optionTotalVotes;
      results.m_winningOptionVotingPower = g_ProposalsMap[proposalID].m_optVoteStatsMap[0].m_optionVotingPower;

      for (uint i = 1; i < g_ProposalsMap[proposalID].m_numOptions; ++i)
      {
        if (results.m_winningOptionVotingPower < g_ProposalsMap[proposalID].m_optVoteStatsMap[i].m_optionVotingPower)
        {
          results.m_winningOptionIndex = i;
          results.m_winningOptionVotingPower = g_ProposalsMap[proposalID].m_optVoteStatsMap[i].m_optionVotingPower;
        }
      }

      if (g_ProposalsMap[proposalID].m_state != State.Cancelled)
      {
        if (results.m_winningOptionIndex == (g_ProposalsMap[proposalID].m_numOptions - 1))
        {
          g_ProposalsMap[proposalID].m_state = State.Rejected;
        }
        else
        {
          g_ProposalsMap[proposalID].m_state = State.Approved;
        }
      }

      results.m_winningOptionTotalVotes = g_ProposalsMap[proposalID].m_optVoteStatsMap[results.m_winningOptionIndex].m_optionTotalVotes;
    }
    else
    {
      g_ProposalsMap[proposalID].m_state = State.Cancelled;
    }

    g_ProposalResultsMap[proposalID] = results;
  }

}
