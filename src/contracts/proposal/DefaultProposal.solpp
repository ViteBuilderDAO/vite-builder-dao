pragma soliditypp ^0.4.3;

import "./proposal-libs/SafeMath.solpp";

contract DefaultProposal
{
  using SafeMath for uint256;

  // Various states that a proposal can be in
  enum State
  {
    Fundraising,
    Complete
  }

  // Proposal Type Obj and it's map container
  // mapping from numberofProposals to ProposalObj
  mapping(uint256 => ProposalObj) proposalsMap;
  struct ProposalObj
  {
    address m_creator;
    string m_title;
    string m_description;
    uint m_raiseUntil;
    uint256 m_balance;
    State m_state;
    bytes32 m_payoutHash;
    mapping (address => uint) m_contributions;
  }

  // Number of proposals currently active
  uint256 public g_currNumProposals = 0;
  // Address of the contract creator
  address g_contractOwner;

  // Event that will be emitted whenever a new proposal is started
  event ProposalStartedEvent(address proposalStarter, string proposalTitle, string proposalDesc, uint256 proposalDeadline, uint256 proposalID);
  // Event that will be emitted whenever a proposal ends
  event ProposalEndedEvent(uint256 proposalID, uint proposalEndTime);
  // Event emitted whenever a proposal receives a vote (funding)
  event ProposalVotedOnEvent(uint256 proposalID, address proposalContributor, uint contributedAmount, uint currentTotal);
  // Event emitted when a proposal has ended and was paid
  event ProposalPaidEvent(uint256 paidProposalID, address paidProposalRecipient);

  /** @dev Contract Constructor
    */
  constructor() public payable
  {
    g_contractOwner = msg.sender;
  }

  /** @dev Function to start a new proposal.
    * @param title Title of the proposal to be created
    * @param description Brief description about the proposal
    * @param durationInDays Proposal deadline in days
    */
  onMessage startProposal(address creator, string calldata title, string calldata description, uint durationInDays)
  {
    uint raiseUntil = now.add(durationInDays.mul(1 days));
    proposalsMap[++g_currNumProposals] = ProposalObj(creator, title, description, raiseUntil, 0, State.Fundraising, 0);

    emit ProposalStartedEvent(creator, title, description, raiseUntil, g_currNumProposals);
  }                                                                                                                              

  /** @dev Function to fund a certain proposal.
    */
  function voteOnProposal(address contributor, uint256 proposalID, uint256 amountValue) public
  {
    require(contributor != proposalsMap[proposalID].m_creator);
    uint256 prevContributions = proposalsMap[proposalID].m_contributions[contributor];
    proposalsMap[proposalID].m_contributions[contributor] = prevContributions.add(amountValue);
    proposalsMap[proposalID].m_balance = proposalsMap[proposalID].m_balance.add(amountValue);
    _requestPayOutOnComplete(proposalID);

    emit ProposalVotedOnEvent(proposalID, contributor, amountValue, proposalsMap[proposalID].m_balance);
  }

  /** @dev Function to get specific information about the proposal.
    * @return Returns all the proposal's details
    */
  function getProposalInfo(uint256 proposalID) public view returns(
    address proposalCreator,
    string memory proposalTitle,
    string memory proposalDesc,
    uint256 proposalDeadline,
    State proposalCurrState,
    uint256 proposalCurrAmount)
  {
    proposalCreator = proposalsMap[proposalID].m_creator;
    proposalTitle = proposalsMap[proposalID].m_title;
    proposalDesc = proposalsMap[proposalID].m_description;
    proposalDeadline = proposalsMap[proposalID].m_raiseUntil;
    proposalCurrState = proposalsMap[proposalID].m_state;
    proposalCurrAmount = proposalsMap[proposalID].m_balance;
  }

  /** @dev Function to get specific information about the proposal.
    * @return Returns all the proposal's details
    */
  function getNumProposals() public view returns(uint256 currNumberOfProposals)
  {
    currNumberOfProposals = g_currNumProposals;
  }

  /** @dev Function to get all proposals' contract addresses.
    * @return A list of all proposals' contract addreses
    */
  //getter returnAllProposals() returns(ProposalObj memory)
  //{
  //    return proposalsMap;
  //}


  /** @dev Function to change the proposal state depending on conditions.
  */
  function stopProposalEarly(uint256 proposalID) public
  {
    // FIX ME - HARDCODED TOKEN - ZD
    proposalsMap[proposalID].m_state = State.Complete;
    _payOut(proposalID, "tti_5649544520544f4b454e6e40");

    emit ProposalEndedEvent(proposalID, now);
  }

  /** @dev Function to change the proposal state depending on conditions.
    */
  function _requestPayOutOnComplete(uint256 proposalID) internal
  {
    // FIX ME - HARDCODED TOKEN - ZD
    require(proposalsMap[proposalID].m_creator == msg.sender);
    if (now > proposalsMap[proposalID].m_raiseUntil)
    {
        proposalsMap[proposalID].m_state = State.Complete;
        _payOut(proposalID, "tti_5649544520544f4b454e6e40");
    }

    emit ProposalEndedEvent(proposalID, now);
  }

  /** @dev Function to give the received funds to proposal starter.
    */
  function _payOut(uint256 proposalID, tokenId tokenID) internal
  {
    address proposalCreator = proposalsMap[proposalID].m_creator;
    require(proposalsMap[proposalID].m_state == State.Complete);
    require(proposalCreator != address(0), 'transfer to zero address');
    uint256 totalRaised = proposalsMap[proposalID].m_balance;
    proposalsMap[proposalID].m_balance = 0;
    proposalsMap[proposalID].m_state = State.Complete;
    proposalCreator.transfer(tokenID, totalRaised);

    emit ProposalPaidEvent(proposalID, proposalCreator);
  }
}