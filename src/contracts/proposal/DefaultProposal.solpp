pragma soliditypp ^0.4.3;

import "./proposal-libs/SafeMath.solpp";

contract DefaultProposal
{
  using SafeMath for uint256;

  // Various states that a proposal can be in
  enum State
  {
    Active,
    Complete
  }

  struct ProposalVote
  {
    string m_voteToken;
    uint256 m_votePower;
  }

  struct ProposalOption
  {
    uint256 m_optionID;
    uint256 m_optionVotePower;
    uint256 m_optionTotalVotes;
    mapping(string => ProposalVote) m_voteMap;
  }

  // Proposal Type Obj and it's map container
  struct ProposalObj
  {
    uint256 m_id;
    address m_creator;
    string m_title;
    string m_description;
    uint m_deadline;
    uint m_numOptions;
    mapping(uint256 => ProposalOption) m_optionsMap;
    uint256 m_totalVotingPower;
    uint256 m_totalVotes;
    State m_state;
  }

  mapping(uint256 => ProposalObj) proposalsMap;

  // Number of proposals currently active
  uint256 g_currNumProposals = 0;
  // Address of the contract creator
  address g_contractOwner;

  // Event that will be emitted whenever a new proposal is created
  event ProposalStartedEvent(
    uint256 indexed proposalID,
    address indexed proposalStarter,
    string proposalTitle,
    string proposalDesc,
    uint256 proposalDeadline
  );

  // Event that will be emitted whenever a proposal ends
  event ProposalEndedEvent(
    uint256 indexed proposalID,
    uint proposalEndTime
  );

  // Event emitted whenever a proposal receives a vote
  event ProposalVotedOnEvent(
    uint256 indexed proposalID,
    address indexed proposalVoter,
    string votingToken,
    uint votingPower,
    uint256 proposalTotalVotingPower,
    uint256 proposalTotalVotes
  );

  // Event emitted when a proposal has ended and results are calculated
  event ProposalResultsCalculated(
    uint256 indexed proposalID,
    address indexed proposalCreator,
    uint256 winningOptionVotes,
    uint256 totalVotes,
    uint256 totalVotingPower
  );

  /** @dev Contract Constructor
    */
  constructor() public
  {
    g_contractOwner = msg.sender;
  }

  /** @dev Function to start a new proposal.
    * @param title Title of the proposal to be created
    * @param description Brief description about the proposal
    * @param durationInDays Proposal deadline in days
    */
  onMessage startProposal(address creator, string calldata title, string calldata description, uint numOptions, uint durationInDays)
  {
    uint proposalDeadline = now.add(durationInDays.mul(1 days));
    uint256 proposalID = ++g_currNumProposals;
    proposalsMap[proposalID] = ProposalObj(proposalID, creator, title, description, proposalDeadline, numOptions, 0, 0, State.Active);

    for(uint i = 0; i < numOptions; ++i)
    {
      proposalsMap[proposalID].m_optionsMap[i] = ProposalOption(i, 0, 0);
    }

    emit ProposalStartedEvent(proposalID, creator, title, description, proposalDeadline);
  }                                                                                                                              

  /** @dev Function to vote on a given proposal.
    */
  onMessage voteOnProposal(address voter, uint256 proposalID, string calldata voteToken, uint256 voterPower, uint optionNumber)
  {
    //require(proposalsMap[proposalID].m_creator != voter);

    proposalsMap[proposalID].m_optionsMap[optionNumber].m_voteMap[voteToken].m_votePower = proposalsMap[proposalID].m_optionsMap[optionNumber].m_voteMap[voteToken].m_votePower.add(voterPower);
    proposalsMap[proposalID].m_optionsMap[optionNumber].m_optionVotePower = proposalsMap[proposalID].m_optionsMap[optionNumber].m_optionVotePower.add(voterPower);
    proposalsMap[proposalID].m_totalVotingPower = proposalsMap[proposalID].m_totalVotingPower.add(voterPower);
    _checkIsComplete(proposalID);

    emit ProposalVotedOnEvent(proposalID, voter, voteToken, voterPower, proposalsMap[proposalID].m_totalVotingPower, ++proposalsMap[proposalID].m_totalVotes);
  }

  /** @dev Stop the proposal early if desired (mostly for testing purposes)
  */
  onMessage stopProposalEarly(uint256 proposalID)
  {
    require(proposalsMap[proposalID].m_creator == msg.sender);

    proposalsMap[proposalID].m_state = State.Complete;
    _calculateResults(proposalID);

    emit ProposalEndedEvent(proposalID, now);
  }

  /** @dev Function to get specific information about the proposal.
    * @return Returns all the proposal's details
    */
  //function getProposalInfo(uint256 proposalID) offchain view returns(
  //  address proposalCreator,
  //  string memory proposalTitle,
  //  string memory proposalDesc,
  //  uint256 proposalDeadline,
  //  State proposalCurrState,
  //  uint proposalNumOptions,
  //  uint256 proposalTotalVotingPower,
  //  uint256 proposalTotalVotes)
  //{
  //  // m_creator
  //  proposalCreator = proposalsMap[proposalID].m_creator;
  //  // m_title
  //  proposalTitle = proposalsMap[proposalID].m_title;
  //  // m_description
  //  proposalDesc = proposalsMap[proposalID].m_description;
  //  // m_deadline
  //  proposalDeadline = proposalsMap[proposalID].m_deadline;
  //  // m_state
  //  proposalCurrState = proposalsMap[proposalID].m_state;
  //  // m_numOptions
  //  proposalNumOptions = proposalsMap[proposalID].m_numOptions;
  //  // m_totalVotingPower
  //  proposalTotalVotingPower = proposalsMap[proposalID].m_deadline;
  //  // m_totalVotes
  //  proposalTotalVotes = proposalsMap[proposalID].m_totalVotes;
  //}

  /** @dev Function to get specific information about the proposal.
    * @return Returns all the proposal's details
    */
  //function getNumProposals() offchain view returns(uint256 currNumberOfProposals)
  //{
  //  currNumberOfProposals = g_currNumProposals;
  //}

  /** @dev Function to get all proposals' contract addresses.
    * @return A list of all proposals' contract addreses
    */
  //getter returnAllProposals() returns(ProposalObj memory)
  //{
  //    return proposalsMap;
  //}

  function getIsPropopsalComplete(uint256 proposalID) public returns(bool)
  {
    return _checkIsComplete(proposalID);
  }

  /** @dev Function to change the proposal state depending on conditions.
    */
  function _checkIsComplete(uint256 proposalID) internal returns(bool)
  {
    // require(proposalsMap[proposalID].m_creator == msg.sender);

    if (now > proposalsMap[proposalID].m_deadline)
    {
        proposalsMap[proposalID].m_state = State.Complete;
        _calculateResults(proposalID);
        emit ProposalEndedEvent(proposalID, now);
        return true;
    }

    return false;
  }

  /** @dev Function to calculate results of proposal when complete
    */
  function _calculateResults(uint256 proposalID) internal
  {
    require(proposalsMap[proposalID].m_state == State.Complete);

    // Proposal creator
    address proposalCreator = proposalsMap[proposalID].m_creator;

    // Winning option and num votes
    ProposalOption memory winningOption = proposalsMap[proposalID].m_optionsMap[0];
    for(uint i = 1; i < proposalsMap[proposalID].m_numOptions; ++i)
    {
      if (winningOption.m_optionVotePower < proposalsMap[proposalID].m_optionsMap[i].m_optionVotePower)
        winningOption = proposalsMap[proposalID].m_optionsMap[i];
    }
    uint256 winningOptionVotes = winningOption.m_optionTotalVotes;

    // Total votes
    uint256 totalVotes = proposalsMap[proposalID].m_totalVotes;

    // Total voting power
    uint256 totalVotingPower = proposalsMap[proposalID].m_totalVotingPower;

    // Set the proposal state to complete (may already be set, but just in case)
    proposalsMap[proposalID].m_state = State.Complete;

    emit ProposalResultsCalculated(proposalID, proposalCreator, winningOptionVotes, totalVotes, totalVotingPower);
  }
}